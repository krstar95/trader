import { markets } from '../protobufs'
import { ofType } from 'redux-observable'
import { map, filter, ignoreElements, switchMap, take } from 'rxjs/operators'
import { ajax } from 'rxjs/ajax'
import { MQTT_CONNECTED, MQTT_RX, MQTT_SEND_, MQTT_SUBSCRIBE_ } from './mqtt'
import { List } from 'immutable'
import { decodeProtobuf } from '../utils/utils'
import uuidv4 from 'uuid/v4'
import { SESSION_FETCHED } from './session'

// action types generated by client
//
export const ORDERS_NEW = 'ORDERS:NEW'
export const ORDERS_CANCEL = 'ORDERS:CANCEL'
export const ORDERS_MODIFY = 'ORDERS:MODIFY'
export const ORDERS_FETCHED = 'ORDERS:FETCHED'

// action types received from system
//
export const ORDERS_RX_NEW = 'ORDERS:RX_NEW'
export const ORDERS_RX_CANCEL = 'ORDERS:RX_CANCEL'

// order status events
//
export const ORDERS_RX_STATUS = 'ORDERS:RX_STATUS'
export const ORDERS_RX_FILL = 'ORDERS:RX_FILL'

// cancel status events
//
export const ORDERS_RX_CANCEL_STATUS = 'ORDERS:RX_CANCEL_STATUS'


// order status codes
//
export const OS_NEW          = markets.OrderStatusCode.OS_NEW
export const OS_PENDING      = markets.OrderStatusCode.OS_PENDING
export const OS_REJECTED     = markets.OrderStatusCode.OS_REJECTED
export const OS_OPEN         = markets.OrderStatusCode.OS_OPEN
export const OS_CANCELED     = markets.OrderStatusCode.OS_CANCELED
export const OS_PARTIAL_FILL = markets.OrderStatusCode.OS_PARTIAL_FILL
export const OS_FILLED       = markets.OrderStatusCode.OS_FILLED

// action constructors
//
export const ORDERS_NEW_ = (userID, profileID, pocketID, symbol, side, orderType, price, quantity, stopPrice) => ({
  type: ORDERS_NEW,
  userID,
  profileID,
  pocketID,
  clOrdID: uuidv4(),
  symbol,
  side,
  orderType,
  price: price == null ? 0 : price,
  quantity,
  stopPrice: stopPrice == null ? 0 : stopPrice
})

export const ORDERS_FETCHED_ = orders =>
  ({ type: ORDERS_FETCHED, orders })
export const ORDERS_CANCEL_ = order =>
  ({ type: ORDERS_CANCEL, order, requestID: uuidv4() })
export const ORDERS_MODIFY_ = (clOrdID, quantity) =>
  ({ type: ORDERS_MODIFY, clOrdID, quantity })

export const ORDERS_RX_NEW_ = (symbol, newOrder) =>
  ({ type: ORDERS_RX_NEW, symbol, newOrder })
export const ORDERS_RX_CANCEL_ = cancel =>
  ({ type: ORDERS_RX_CANCEL, cancel })
export const ORDERS_RX_STATUS_ = status =>
  ({ type: ORDERS_RX_STATUS, status })

export const ORDERS_RX_FILL_ = fill =>
  ({ type: ORDERS_RX_FILL, fill })

export const ORDERS_RX_CANCEL_STATUS_ = status =>
  ({ type: ORDERS_RX_CANCEL_STATUS, status })


// Lookup clOrdID by orderID.
//
let CLIENT_ID = {}

// reducer
//
export const orders = (state = {}, action) => {
  switch (action.type) {
  default:
    return state

  case ORDERS_FETCHED:
    //
    // TBD: Do we need to worry about overwriting an order
    //      submitted before the load response arrives?
    //
    //      If so then this will overwrite it and lose information.
    //
    var newState = {...state}
    action.orders.map(order => {
      CLIENT_ID[order.orderID] = order.clOrdID
      newState[order.clOrdID] = {
      	order: order,
        history: new List() // TBD: include in load
      }
      return null
    })
    return newState

  case ORDERS_NEW:
    const { userID, profileID, pocketID, clOrdID, symbol, side, orderType, price, quantity, stopPrice } = action
    return {
      ...state,
      [action.clOrdID]: {
        order: new markets.Order({
          userID,
          profileID,
          pocketID,
          clOrdID,
          side,
          orderType,
          price,
          quantity,
          stopPrice,
          market: symbol,
          status: markets.OrderStatusCode.OS_NEW,
          filled: 0,
          filledCost: 0
        }),
        history: List.of(actionEvent(null)) // NEW before server tells us.
                                            // not sure what to put here
      }
    }

  case ORDERS_RX_NEW:
    CLIENT_ID[action.newOrder.orderID] = action.newOrder.clOrdID
    var existing = state[action.newOrder.clOrdID]
    var history
    var order
    if (existing) {
      order = new markets.Order(existing.order)
      //
      // In either case this is the first time we learn the
      // system's official orderID.
      //
      order.orderID = action.newOrder.orderID
      order.timestamp = action.newOrder.timestamp
      history = existing.history
    }
    else {
      existing = {}
      order = new markets.Order({
        ...action.newOrder,
        market: action.symbol,
        status: markets.OrderStatusCode.OS_NEW,
        filled: 0,
        filledCost: 0
      })
      history = new List()
    }
    return {
      ...state,
      [order.clOrdID]: {
        ...existing,
        order: order,
        history: history.push(actionEvent(markets.OrderStatusCode.NEW))
      }
    }

  case ORDERS_RX_STATUS:
    var existing = state[action.status.clOrdID]
    if (existing) {
      let order = new markets.Order(existing.order)
      if (!is_sequential_status(order.status, action.status.event.code)) {
        if (is_old_status(action.status.event.code, order.status)) {
          console.warn('IGNORED OLD STATUS ' + action.status.clOrdID + ' ' + action.status.event.code + ' current=' + order.status)
          // prevent earlier status from overwriting later status
          return state
        }
        else if (is_invalid_transition(order.status, action.status.event.code)) {
          console.error('INVALID STATUS CHANGE ' + action.status.clOrdID + ' ' + order.status + '->' + action.status.event.code)
          // in this case we use the last one received.
          // Maybe it was because of a corrected status although no such status correction
          // features existed at the time this code was written.
        }
        else {
          // Assume status received earlier than expected.
          console.warn('EARLY STATUS ' + action.status.clOrdID + ' ' + order.status + '->' + action.status.event.code)
        }
      }
      order.status = action.status.event.code
      order.filled = action.status.filled;
      order.filledCost = action.status.filledCost;
      return {
        ...state,
        [action.status.clOrdID]: {
          ...existing,
          order: order,
          history: existing.history.push(actionEvent(action.status.event.code))
        }
      }
    }
    else {
      //
      // This should ideally never happen.  It means that the order was in flight
      // when this page loaded and was missed by both the ORDERS_FETCHED and ORDERS_RX_NEW.
      //
      console.log('in-flight order missed by ORDERS_RX_NEW')
      return state
    }

  case ORDERS_CANCEL:
    var existing = state[action.order.clOrdID]
    return {
      ...state,
      [action.order.clOrdID]: {
      	...existing,
        history: existing.history.push(actionEvent(action.type)),
        cancelStatus: new markets.CancelStatus({
          requestID: action.requestID,
          orderID: action.order.orderID, // may be (null or 0) = unknown
          clientKey: markets.ClientKey({
            pocketID: action.order.pocketID,
            clOrdID: action.order.clOrdID
          }),
          code: markets.CancelStatusCode.CS_NEW
        })
      }
    }

  case ORDERS_RX_CANCEL_STATUS:
    var clOrdID = CLIENT_ID[action.status.orderID]
    if (!clOrdID) {
      return state
    }
    var existing = state[clOrdID]
    return {
      ...state,
      [clOrdID]: {
      	...existing,
      	history: existing.history.push(actionEvent(action.type)),
      	cancelStatus: action.status
      }
    }
  }
}

const actionEvent = action_type => ({
  action: action_type,
  time: Date.now() // millis since January 1, 1970
})

export const epics = [

  // fetch orders
  //
  action$ => action$.pipe(
    ofType(SESSION_FETCHED),
    filter(action => action.session.isAuthorized),
    take(1),
    switchMap(() =>
      ajax.getJSON('/api/orders/').pipe(
        map(response => {
          let orders = decodeProtobuf(markets.OrderList, response)
          return ORDERS_FETCHED_(orders.orders)
        })))),

  // new order
  //
  (action$, state$) => action$.pipe(
    ofType(ORDERS_NEW),
    map(action => {
      let newOrder = new markets.NewOrder(action)
      let session = state$.value.session
      // topic order/<market_symbol>/<user_id>/<profile_id>/<pocket_id>
      return MQTT_SEND_(`order/${action.symbol}/${action.userID}/${action.profileID}/${action.pocketID}`,
		      markets.NewOrder.encode(newOrder).finish())
    })),

  // cancel order
  //
  action$ => action$.pipe(
    ofType(ORDERS_CANCEL),
    map(action => {
      let cancel = new markets.CancelOrder()
      cancel.requestID = action.requestID
      if (action.order.orderID && action.order.orderID != 0) {
      	cancel.orderID = action.order.orderID
      }
      else {
      	cancel.clientKey = markets.ClientKey({
          clOrdID: action.order.clOrdID,
          pocketID: action.order.pocketID
        })
      }
      return MQTT_SEND_(`cancel/${action.order.market}/${action.order.userID}`,
        markets.CancelOrder.encode(cancel).finish())})),

  // subscribe to order actions
  //
  (action$, state$) => action$.pipe(
    ofType(MQTT_CONNECTED),
    map(() =>
      // topic action/<market_symbol>/<user_id>/<profile_id>/<pocket_id>
      MQTT_SUBSCRIBE_(`action/+/+/+/${state$.value.session.pocketID}`))),

  // subscribe to order statuses
  //
  (action$, state$) => action$.pipe(
    ofType(MQTT_CONNECTED),
    map(() =>
    	// topic order_status/<market_symbol>/<user_id>/<profile_id>/<pocket_id>
	    MQTT_SUBSCRIBE_(`order_status/+/+/+/${state$.value.session.pocketID}`))),

  // subscribe to cancel statuses
  //
  (action$, state$) => action$.pipe(
    ofType(MQTT_CONNECTED),
    map(() =>
    	// Subscribe to cancel status for current user.
    	//
    	// topic cancel_status/<market_symbol>/<user_id>/<profile_id>/<pocket_id>
    	MQTT_SUBSCRIBE_(`cancel_status/+/${state$.value.session.userID}/+/+`))),

  // receive order action
  //
  action$ => action$.pipe(
    ofType(MQTT_RX),
    filter(action =>
      action.topic[0] == 'action'),
    map(action => {
      let rxAction = markets.Action.decode(action.message)
      switch(rxAction.msg) {
      default:
        return ignoreElements()
      case "newOrder":
        return ORDERS_RX_NEW_(action.topic[1], rxAction.newOrder)
      case "cancelOrder":
        return ORDERS_RX_CANCEL_(rxAction.cancelOrder)
      }
    })),

  // receive order status
  //
  action$ => action$.pipe(
    ofType(MQTT_RX),
    filter(action =>
	   action.topic[0] == 'order_status'),
    map(action =>
      ORDERS_RX_STATUS_(markets.OrderStatus.decode(action.message)))),

  // receive order status
  //
  action$ => action$.pipe(
    ofType(MQTT_RX),
    filter(action =>
      action.topic[0] == 'cancel_status'),
    map(action =>
      ORDERS_RX_CANCEL_STATUS_(markets.CancelStatus.decode(action.message)))),

  // detect fills
  //
  action$ => action$.pipe(
    ofType(ORDERS_RX_STATUS),
    filter(action =>
      action.status.event.code == markets.OrderStatusCode.OS_PARTIAL_FILL ||
      action.status.event.code == markets.OrderStatusCode.OS_FILLED),
    map(action =>
      ORDERS_RX_FILL_(action.status)))
]

// Valid Order Status Finite State Machine Transitions
// 
// Although these transitions represent the actual sequence of events
// in the distributed order management system, it is possible that some
// statuses may be received earlier than statuses that will be received
// from events that had already occured.  This may either be due to
// latency optimizations or partial order management system failures.
//
const TRANSITIONS = {
    [OS_NEW]:          [OS_REJECTED, OS_PENDING],
    [OS_PENDING]:      [OS_REJECTED, OS_OPEN],
    [OS_REJECTED]:     [],
    [OS_OPEN]:         [OS_CANCELED, OS_PARTIAL_FILL, OS_FILLED],
    [OS_CANCELED]:     [],
    [OS_PARTIAL_FILL]: [OS_PARTIAL_FILL, OS_FILLED],
    [OS_FILLED]:       []
}

function is_sequential_status(lastKnown, status) {
  return -1 != TRANSITIONS[lastKnown].indexOf(status)
}

const PRIORS = {
    [OS_NEW]:          [],
    [OS_PENDING]:      [OS_NEW],
    [OS_REJECTED]:     [OS_PENDING, OS_NEW],
    [OS_OPEN]:         [OS_PENDING, OS_NEW],
    [OS_CANCELED]:     [OS_OPEN, OS_PENDING, OS_NEW],
    [OS_PARTIAL_FILL]: [OS_OPEN, OS_PENDING, OS_NEW],
    [OS_FILLED]:       [OS_PARTIAL_FILL, OS_OPEN, OS_PENDING, OS_NEW]
}

function is_old_status(status, lastKnown) {
  return -1 != PRIORS[lastKnown].indexOf(status)
}

// Invalid Future Transitions
//
// Given a starting status, ignoring early statuses,
// what transitions are invalid regardless of any intermediate statuses.
// 
const INVALID_TRANSITIONS = {
  [OS_NEW]: [],
  [OS_PENDING]: [],
  [OS_REJECTED]: [OS_CANCELED, OS_FILLED],
  [OS_OPEN]: [OS_REJECTED],
  [OS_CANCELED]: [OS_REJECTED, OS_FILLED],
  [OS_PARTIAL_FILL]: [OS_REJECTED],
  [OS_FILLED]: [OS_REJECTED, OS_CANCELED]
}

function is_invalid_transition(lastKnown, status) {
  return -1 != INVALID_TRANSITIONS[lastKnown].indexOf(status)
}

